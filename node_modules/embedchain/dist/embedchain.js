"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbedChainApp = void 0;
const document_1 = require("langchain/document");
const openai_1 = require("openai");
const chunkers_1 = require("./chunkers");
const loaders_1 = require("./loaders");
const vectordb_1 = require("./vectordb");
const configuration = new openai_1.Configuration({
    apiKey: process.env.OPENAI_API_KEY,
});
const openai = new openai_1.OpenAIApi(configuration);
class EmbedChain {
    constructor(db = null) {
        this.userAsks = [];
        if (!db) {
            this.initApp = this.setupChroma();
        }
        else {
            this.initApp = this.setupOther(db);
        }
    }
    setupChroma() {
        return __awaiter(this, void 0, void 0, function* () {
            const db = new vectordb_1.ChromaDB();
            yield db.initDb;
            this.dbClient = db.client;
            if (db.collection) {
                this.collection = db.collection;
            }
            else {
                // TODO: Add proper error handling
                console.error('No collection');
            }
        });
    }
    setupOther(db) {
        return __awaiter(this, void 0, void 0, function* () {
            yield db.initDb;
            // TODO: Figure out how we can initialize an unknown database.
            // this.dbClient = db.client;
            // this.collection = db.collection;
            this.userAsks = [];
        });
    }
    static getLoader(dataType) {
        const loaders = {
            pdf_file: new loaders_1.PdfFileLoader(),
            web_page: new loaders_1.WebPageLoader(),
            qna_pair: new loaders_1.LocalQnaPairLoader(),
        };
        return loaders[dataType];
    }
    static getChunker(dataType) {
        const chunkers = {
            pdf_file: new chunkers_1.PdfFileChunker(),
            web_page: new chunkers_1.WebPageChunker(),
            qna_pair: new chunkers_1.QnaPairChunker(),
        };
        return chunkers[dataType];
    }
    add(dataType, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const loader = EmbedChain.getLoader(dataType);
            const chunker = EmbedChain.getChunker(dataType);
            this.userAsks.push([dataType, url]);
            yield this.loadAndEmbed(loader, chunker, url);
        });
    }
    addLocal(dataType, content) {
        return __awaiter(this, void 0, void 0, function* () {
            const loader = EmbedChain.getLoader(dataType);
            const chunker = EmbedChain.getChunker(dataType);
            this.userAsks.push([dataType, content]);
            yield this.loadAndEmbed(loader, chunker, content);
        });
    }
    loadAndEmbed(loader, chunker, src) {
        return __awaiter(this, void 0, void 0, function* () {
            const embeddingsData = yield chunker.createChunks(loader, src);
            let { documents, ids, metadatas } = embeddingsData;
            const existingDocs = yield this.collection.get({ ids });
            const existingIds = new Set(existingDocs.ids);
            if (existingIds.size > 0) {
                const dataDict = {};
                for (let i = 0; i < ids.length; i += 1) {
                    const id = ids[i];
                    if (!existingIds.has(id)) {
                        dataDict.id = { doc: documents[i], meta: metadatas[i] };
                    }
                }
                if (Object.keys(dataDict).length === 0) {
                    console.log(`All data from ${src} already exists in the database.`);
                    return;
                }
                ids = Object.keys(dataDict);
                const dataValues = Object.values(dataDict);
                documents = dataValues.map(({ doc }) => doc);
                metadatas = dataValues.map(({ meta }) => meta);
            }
            yield this.collection.add({ documents, metadatas, ids });
            console.log(`Successfully saved ${src}. Total chunks count: ${yield this.collection.count()}`);
        });
    }
    static formatResult(results) {
        return __awaiter(this, void 0, void 0, function* () {
            return results.documents[0].map((document, index) => {
                const metadata = results.metadatas[0][index] || {};
                // TODO: Add proper error handling
                const distance = results.distances ? results.distances[0][index] : null;
                return [new document_1.Document({ pageContent: document, metadata }), distance];
            });
        });
    }
    static getOpenAiAnswer(prompt) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const messages = [
                { role: 'user', content: prompt },
            ];
            const response = yield openai.createChatCompletion({
                model: 'gpt-3.5-turbo',
                messages,
                temperature: 0,
                max_tokens: 1000,
                top_p: 1,
            });
            return ((_b = (_a = response.data.choices[0].message) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : 'Response could not be processed.');
        });
    }
    retrieveFromDatabase(inputQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.collection.query({
                nResults: 1,
                queryTexts: [inputQuery],
            });
            const resultFormatted = yield EmbedChain.formatResult(result);
            const content = resultFormatted[0][0].pageContent;
            return content;
        });
    }
    static generatePrompt(inputQuery, context) {
        const prompt = `Use the following pieces of context to answer the query at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n${context}\nQuery: ${inputQuery}\nHelpful Answer:`;
        return prompt;
    }
    static getAnswerFromLlm(prompt) {
        return __awaiter(this, void 0, void 0, function* () {
            const answer = yield EmbedChain.getOpenAiAnswer(prompt);
            return answer;
        });
    }
    query(inputQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.retrieveFromDatabase(inputQuery);
            const prompt = EmbedChain.generatePrompt(inputQuery, context);
            const answer = yield EmbedChain.getAnswerFromLlm(prompt);
            return answer;
        });
    }
    dryRun(input_query) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.retrieveFromDatabase(input_query);
            const prompt = EmbedChain.generatePrompt(input_query, context);
            return prompt;
        });
    }
}
class EmbedChainApp extends EmbedChain {
}
exports.EmbedChainApp = EmbedChainApp;
//# sourceMappingURL=embedchain.js.map